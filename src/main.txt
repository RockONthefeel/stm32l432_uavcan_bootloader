#include <Arduino.h>
#include <IWatchdog.h>
#include <CRC32.h>

#include <stm32l432kc_hal.h>
#include <drivers/stm32/canard_stm32.h>
#include <iap_node.h>

// #define DEBUG_APPLICATION_INPLACE    1 /* Never leave defined */
#define DEBUG_NO_FW_UPDATE 1 /* With DEBUG_APPLICATION_INPLACE \
                              * prevents fw update             \
                              */

/* Using 2 character text in  LogMessage */

#define LOGMESSAGE_STAGE_INIT 'I'
#define LOGMESSAGE_STAGE_GET_INFO 'G'
#define LOGMESSAGE_STAGE_ERASE 'E'
#define LOGMESSAGE_STAGE_READ 'R'
#define LOGMESSAGE_STAGE_PROGRAM 'P'
#define LOGMESSAGE_STAGE_VALIDATE 'V'
#define LOGMESSAGE_STAGE_FINALIZE 'F'

#define LOGMESSAGE_RESULT_START 's'
#define LOGMESSAGE_RESULT_FAIL 'f'
#define LOGMESSAGE_RESULT_OK 'o'

typedef enum
{
  FLASH_OK = 0,
  FLASH_ERROR,
  FLASH_ERASE_ERROR,
  FLASH_ERASE_VERIFY_ERROR,
  FLASH_ERROR_SUICIDE,
  FLASH_ERROR_AFU,

} flash_error_t;

typedef struct{
	uint8_t signature[sizeof(uint64_t)];
	union {
		uint64_t image_crc;
		struct {
			uint32_t crc32_block1;
			uint32_t crc32_block2;
		};
	};
	uint32_t image_size;
	uint32_t git_hash;
	uint8_t  major_version;
	uint8_t  minor_version;
	uint16_t board_id;
	uint8_t reserved[ 3 + 3 + 2];
} app_descriptor_t;

typedef struct
{
  union
  {
    uint64_t ull;
    uint32_t ul[2];
    uint8_t valid;
  } crc;
  uint32_t signature;
  uint32_t bus_speed;
  uint32_t node_id;
} bootloader_app_shared_t;

typedef struct
{
  uint8_t signature[sizeof(uint64_t)];
  union
  {
    uint64_t image_crc;
    struct
    {
      uint32_t crc32_block1;
      uint32_t crc32_block2;
    };
  };
  uint32_t image_size;
  uint32_t git_hash;
  uint8_t major_version;
  uint8_t minor_version;
  uint16_t board_id;
  uint8_t reserved[3 + 3 + 2];
} app_descriptor_t;

typedef volatile struct
{
  volatile uint8_t health;
  volatile uint8_t mode;
  volatile uint8_t sub_mode;
  volatile bool app_valid;
  volatile uint32_t uptime;
  volatile app_descriptor_t *fw_image_descriptor;
  volatile uint32_t *fw_image;
  bool wait_for_getnodeinfo;
  bool app_bl_request;
  bool sent_node_info_response;
  uint16_t percentage_done;
  union
  {
    uint32_t l;
    uint8_t b[sizeof(uint32_t)];
  } fw_word0[1];
} bootloader_t;

bootloader_t bootloader;

HardwareSerial Serial1(USART1);

void setup()
{
  size_t fw_image_size = 0;
  uavcan_protocol_file_Path fw_path;
  size_t fw_path_length;
  uint8_t error_log_stage;
  flash_error_t status;
  bootloader_app_shared_t common;

  IWatchdog.begin(5000000);
  while (!IWatchdog.isEnabled())
    ;
  IWatchdog.reload();

  memset((void *)&bootloader, 0, sizeof(bootloader));

  canardSetLocalNodeID(&canard, MY_NODE_ID);
  bootloader.health = UAVCAN_PROTOCOL_NODESTATUS_HEALTH_OK;
  bootloader.mode = UAVCAN_PROTOCOL_NODESTATUS_MODE_INITIALIZATION;
  bootloader.sub_mode = 0;

  error_log_stage = LOGMESSAGE_STAGE_INIT;

  bootloader.fw_image = (volatile uint32_t *)(APP_START_ADDRESS);

  bootloader.wait_for_getnodeinfo = 1;

  bootloader.app_valid = is_app_valid(bootloader.fw_image);
  
  bootloader.app_bl_request = (OK == bootloader_app_shared_read(&common, App)) &&
                              common.bus_speed && common.node_id;

  common.crc.valid = false;
  bootloader_app_shared_invalidate();

boot:
  IWatchdog.reload();
  application_run(bootloader.fw_image_descriptor->image_size);
failure:
  send_log_message(LOGMESSAGE_LEVELERROR,
                   error_log_stage,
                   LOGMESSAGE_RESULT_FAIL);
  bootloader.health = UAVCAN_PROTOCOL_NODESTATUS_HEALTH_CRITICAL;
  delay(20000);
  NVIC_SystemReset();
}

void loop()
{
  // processTxRxOnce(10);

  // const uint64_t ts = getCurrentMicros();
  // if (ts >= next_1hz_service_at)
  // {
  //   next_1hz_service_at += 1000000ULL;
  //   process1HzTasks(ts);
  // }
  // if (fwupdate.node_id != 0)
  // {
  //   send_firmware_read();
  // }

  // if (fwupdate.restart_flag)
  // {
  //   processTxRxOnce(1);
  //   __NVIC_SystemReset();
  // }
}

void application_run(size_t fw_image_size)
{
  uint32_t *fw_header = (uint32_t *)APP_START_ADDRESS;
  uint32_t stack_pointer = fw_header[0];
  uint32_t entry_point = fw_header[1];

  if (stack_pointer != 0xFFFFFFFF &&
      entry_point >= APP_START_ADDRESS &&
      entry_point < (APP_START_ADDRESS + fw_image_size))
  {
    noInterrupts();
    Serial1.end();
    // 其他外设关闭代码...

    SysTick->CTRL = 0;
    __DSB();
    __ISB();
    SCB->ICSR |= SCB_ICSR_PENDSTCLR_Msk;

    // 更新共享内存（如果CRC有效）
    // if (common->valid)
    // {
    //   // 写入共享内存数据
    //   common->crc = calculate_crc32(); // 需要实现CRC计算函数
    // }

    __DSB();
    __ISB();
    SCB->VTOR = APP_START_ADDRESS;
    __DSB();

    IWatchdog.clearReset();
    IWatchdog.begin(5000000);
    while (!IWatchdog.isEnabled())
      ;
    IWatchdog.reload();

    jump_to_app();

    while (1)
      ;
  }
}

static void find_descriptor(void)
{
  const uint8_t APP_SIGNATURE[8] = {0x40, 0xa2, 0xe4, 0xf1, 0x64, 0x68, 0x91, 0x06};
  const uint32_t APP_START = APP_START_ADDRESS;
  const uint32_t APP_END = PARAM_ADDRESS - 1;

  bootloader.fw_image_descriptor = nullptr;

  const uint8_t *flash_ptr = (const uint8_t *)APP_START;
  const size_t signature_len = sizeof(APP_SIGNATURE);

  for (; flash_ptr <= (const uint8_t *)(APP_END - signature_len); flash_ptr++)
  {
    if (memcmp(flash_ptr, APP_SIGNATURE, signature_len) == 0)
    {
      bootloader.fw_image_descriptor = (volatile app_descriptor_t *)flash_ptr;
      return;
    }
  }
}

static bool is_app_valid(volatile uint32_t *first_words)
{
  CRC32 crc;

  find_descriptor();

  if (!bootloader.fw_image_descriptor || first_words[0] == 0xFFFFFFFFu)
  {
    Serial1.println("Invalid: No descriptor or empty first word");
    return false;
  }

  size_t length = bootloader.fw_image_descriptor->image_size;
  if (length > (PARAM_ADDRESS + 1 - APP_START_ADDRESS) || length == 0)
  {
    Serial1.println("Invalid: Bad image size");
    return false;
  }

  size_t block2_len = bootloader.fw_image_descriptor->image_size - ((size_t)&bootloader.fw_image_descriptor->major_version - (size_t)bootloader.fw_image);
  if (block2_len > (PARAM_ADDRESS + 1 - APP_START_ADDRESS) || block2_len == 0)
  {
    Serial.println("Invalid: Bad block2 size");
    return false;
  }

  crc.reset();
  crc.add((const uint8_t *)first_words, 1 * sizeof(uint32_t));
  size_t block1_part2_len = (size_t)&bootloader.fw_image_descriptor->crc32_block1 - (size_t)(bootloader.fw_image + 1);
  crc.add((const uint8_t *)(bootloader.fw_image + 1), block1_part2_len);
  uint32_t block_crc1 = crc.calc();

  crc.reset();
  crc.add((const uint8_t *)&bootloader.fw_image_descriptor->major_version, block2_len);
  uint32_t block_crc2 = crc.calc();

  bool crc_valid = (block_crc1 == bootloader.fw_image_descriptor->crc32_block1) &&
                   (block_crc2 == bootloader.fw_image_descriptor->crc32_block2);

  if (!crc_valid)
  {
    Serial1.println("Invalid: CRC mismatch");
    Serial1.print("Expected: ");
    Serial1.print(bootloader.fw_image_descriptor->crc32_block1, HEX);
    Serial1.print(", ");
    Serial1.println(bootloader.fw_image_descriptor->crc32_block2, HEX);
    Serial1.print("Actual: ");
    Serial1.print(block_crc1, HEX);
    Serial1.print(", ");
    Serial1.println(block_crc2, HEX);
  }
  return crc_valid;
}

// void setup()
// {
//   uint8_t error_log_stage;

//   // IWatchdog.isReset(true);
//   // IWatchdog.begin(5000000);
//   Serial1.begin(115200);

//   Serial1.println("Application start...");
//   Serial1.flush(100);
//   jump_to_app();

//   // uint8_t iap_flag = *(volatile uint32_t *)(PARAM_ADDRESS);
//   // if ((iap_flag & 0x01) == 1)
//   // {
//   //   Serial1.println("IAP mode");
//   // }
//   // else
//   // {
//   //   jump_to_app();
//   // }

//   // uint8_t f_data[256];
//   // for (uint16_t i = 0; i < 256; i++)
//   // {
//   //   f_data[i] = i;
//   // }
//   // bool e_status = flash_erase_page(PARAM_ADDRESS, 1);
//   // bool w_status = flash_write(PARAM_ADDRESS, f_data, 256);

//   // memset(f_data, sizeof(f_data), 0);
//   // uint8_t fr_data = 0;
//   // for (uint16_t i = 0; i < 256; i++)
//   // {
//   //   fr_data = (*(volatile uint32_t *)(PARAM_ADDRESS + i)) & 0xFF;
//   //   Serial1.printf("param:%02X\n", fr_data);
//   // }

// #if defined(CAN1)
//   GPIO_InitTypeDef GPIO_InitStruct = {0};
//   /* CAN1 clock enable */
//   __HAL_RCC_CAN1_CLK_ENABLE();
//   __HAL_RCC_GPIOA_CLK_ENABLE();
//   /**CAN1 GPIO Configuration
//   PA11     ------> CAN1_RX
//   PA12     ------> CAN1_TX
//   */
//   GPIO_InitStruct.Pin = GPIO_PIN_11 | GPIO_PIN_12;
//   GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
//   GPIO_InitStruct.Pull = GPIO_NOPULL;
//   GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
//   GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
//   HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
// #endif

//   CanardSTM32CANTimings timings;
//   timings.bit_rate_prescaler = 16;
//   timings.bit_segment_1 = 3;
//   timings.bit_segment_2 = 1;
//   timings.max_resynchronization_jump_width = 1;
//   int16_t result = canardSTM32Init(&timings, CanardSTM32IfaceModeNormal);
//   if (result < 0)
//   {
//     while (1)
//     {
//       Serial1.println("Failed to initialize CAN");
//       delay(1000);
//     }
//   }

//   canardInit(&canard,
//              memory_pool,
//              sizeof(memory_pool),
//              onTransferReceived,
//              shouldAcceptTransfer,
//              NULL);

//   if (MY_NODE_ID > 0)
//   {
//     canardSetLocalNodeID(&canard, MY_NODE_ID);
//   }

//   while (canardGetLocalNodeID(&canard) == CANARD_BROADCAST_NODE_ID)
//   {
//     processTxRxOnce(10);

//     if (getCurrentMillis() > DNA.send_next_node_id_allocation_request_at_ms)
//     {
//       request_DNA();
//     }
//   }

//   next_1hz_service_at = getCurrentMicros();

// boot:
//   IWatchdog.reload();
//   application_run(bootloader.fw_image_descriptor->image_size);
// failure:
//   send_log_message(LOGMESSAGE_LEVELERROR,
//                    error_log_stage,
//                    LOGMESSAGE_RESULT_FAIL);
//   bootloader.health = UAVCAN_PROTOCOL_NODESTATUS_HEALTH_CRITICAL;
//   delay(20000);
//   NVIC_SystemReset();
// }